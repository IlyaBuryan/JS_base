"use strict";

// ------------------------------------------------------ 1. Дан код:
// var a = 1, b = 1, c, d;
// c = ++a; alert(c);           // 2 ===> Строка 2
// d = b++; alert(d);           // 1 ===> Строка 3
// c = (2+ ++a); alert(c);      // 5 ===> Строка 4
// d = (2+ b++); alert(d);      // 4 ===> Строка 5
// alert(a);                    // 3 ===> Строка 6
// alert(b);                    // 3 ===> Строка 7
// Почему код даёт именно такие результаты?

// Для ответа пронумеровал строки:
// ===> Строка 2 вернет 2, потому что префиксный оператор инкремента, сначала увеличит а до 2 (1+1), и только потом присвоит это значение с.
// ===> Строка 3 вернет 1, потому что постфиксный оператор инкремента, сначала присвоит значение d = b, когда b = 1, и только после этого увеличит значение b до 2 (1+1).
// ===> Строка 4 вернет 5, потому что переменная а, которая к этому моменту равна 2 сначала увеличивается на 1, становлясь ранвной 3, и только после к 2 прибавляется 3.
// ===> Строка 5 вернет 4, потому сначала к 2 прибавляется значение переменной b, которая к этому моменту равна 2. А только потом постфиксный оператор инкремента увеличивает b на 1
// ===> Строки 6 и 7 вернут 3, так как к переменной a и переменной b были применены оператора инкремента по 2 раза.


// ------------------------------------------------------ 2. Чему будет равен x в примере ниже?
// var x будет равен 5, потому что сначала выполнится выражение в скобках и переменная а станет равной 4, и только потом вычислится и присвоится значение переменной x как 1+4
// var a = 2;
// var x = 1 + (a *= 2);


// 3. Объявить две целочисленные переменные a и b и задать им произвольные начальные значения. Затем написать скрипт, который работает по следующему принципу:
// если a и b положительные, вывести их разность;
// если а и b отрицательные, вывести их произведение;
// если а и b разных знаков, вывести их сумму; ноль можно считать положительным числом.

const a = parseInt(prompt('Введите целое число а'));
const b = parseInt(prompt('Введите целое число b'));

if (a && b) {
    if (a >= 0 && b >= 0) {
        alert(`Разница по модулю abs(а - b) = ${Math.abs(a - b)}`);
    } else if (a < 0 && b < 0) {
        alert(`Произведение а * b = ${a * b}`);
    } else {
        alert(`Сумма а + b = ${a + b}`);
    }
} else {
    alert('Введены не числа');
}

// 4. ------------ Присвоить переменной а значение в промежутке [0..15]. С помощью оператора switch организовать вывод чисел от a до 15.

let a2 = parseInt(prompt('Введите число от 0 до 15'));

switch (a2) {
    case 0: alert(a2++);
    case 1: alert(a2++);
    case 2: alert(a2++);
    case 3: alert(a2++);
    case 4: alert(a2++);
    case 5: alert(a2++);
    case 6: alert(a2++);
    case 7: alert(a2++);
    case 8: alert(a2++);
    case 9: alert(a2++);
    case 10: alert(a2++);
    case 11: alert(a2++);
    case 12: alert(a2++);
    case 13: alert(a2++);
    case 14: alert(a2++);
    case 15: alert(a2); break;
    default: alert('Введенное значение не удовлетворяет условию задачи!');
}


// 5. ------------ Реализовать основные 4 арифметические операции в виде функций с двумя параметрами. Обязательно использовать оператор return.

function my_sum(x, y) {
    return x + y;
}

function my_sub(x, y) {
    return x - y;
}

function my_mul(x, y) {
    return x * y;
}

function my_div(x, y) {
    return x / y;
}

console.log(my_sum(3, 9))
console.log(my_sub(3, 9))
console.log(my_mul(3, 9))
console.log(my_div(3, 9))


// 6. ------------ Реализовать функцию с тремя параметрами: function mathOperation(arg1, arg2, operation), где arg1, arg2 – значения аргументов, operation – строка с названием операции. В зависимости от переданного значения операции выполнить одну из арифметических операций (использовать функции из пункта 5) и вернуть полученное значение (использовать switch).

function mathOperation(arg1, arg2, operation) {
    switch (operation) {
        case 'sum':
            return my_sum(arg1, arg2);
        case 'sub':
            return my_sub(arg1, arg2);
        case 'mul':
            return my_mul(arg1, arg2);
        case 'div':
            return my_div(arg1, arg2);
        default:
            return NaN;
    }
}

console.log(mathOperation(3, 9, 'mul'))

// 7. ------------ *Сравнить null и 0. Попробуйте объяснить результат.

// Для этого прменяется 'абстрактный алгоритм сравнения для отношений'.
// В соответствии с этим алогритмом для этого случая просто возвращается значение false как по-умолчанию.
console.log(null == 0); // false

// Для этого прменяется 'абстрактный алгоритм сравнения для отношений'. 
// В соответствии с ним: Null преобразуется в +0. Значение +0 равно 0, в результате алгоритм возвращает false. 
console.log(null > 0); // false
console.log(null < 0); // false

// В данном случае вычисляется простое < или >, и как было установлено ранее, оба равны false. Значит просто берется противоположное значение true.
console.log(null >= 0); // true
console.log(null <= 0); // true


// 8. ------------ *С помощью рекурсии организовать функцию возведения числа в степень. Формат: function power(val, pow), где val – заданное число, pow – степень.

// Правда работает только для попложительных целых степеней...
function power(val, pow) {
    if (pow == 1) {
        return val;
    } else {
        return val * power(val, pow - 1);
    }
}

console.log(power(3, 3));